---
# Application name for this connector configuration
app_name: PostgreSQL Test
app_description: Test configuration for PostgreSQL with employee_id and last_login support

# Connection settings for the PostgreSQL database
connect:
  # Data Source Name (DSN) for our test PostgreSQL instance
  dsn: "postgres://${DB_USER}:${DB_PASSWORD}@${DB_HOST}:${DB_PORT}/${DB_DATABASE}?sslmode=disable"

# Definition of different resource types managed by this connector
resource_types:
  # Configuration for "user" resources in PostgreSQL
  user:
    # Display name for this resource type
    name: "User"
    # Description providing context about what a user represents
    description: "A user within the PostgreSQL system"
    # Settings for listing user records from the database
    list:
      # SQL query to fetch user-related data including employee_id, last_login, and manager information
      query: |
        SELECT
          u.id, 
          u.username,
          u.email,
          u.employee_id,
          u.status,
          u.account_type,
          u.created_at,
          u.last_login,
          u.manager_id,
          m.username as manager_username,
          m.email as manager_email
        FROM
          users u
        LEFT JOIN 
          users m ON u.manager_id = m.id
      # Pagination configuration (using offset for PostgreSQL)
      pagination:
        strategy: "offset"
        primary_key: "id"
      # Mapping of query results to resource fields
      map:
        # Unique identifier for the user resource
        id: ".username"
        # Field to display as the resource's name
        display_name: ".username"
        # Additional description for the user resource
        description: ".username"
        # Extra attributes (traits) for the user resource
        traits:
          user:
            # Map status from database (active, disabled) to proper resource status
            status: ".status"
            # Login identifier - username
            login: ".username"
            # Email addresses
            emails:
              - ".email"
            # Account type mapping (convert 'employee' to 'human')
            account_type: ".account_type == 'employee' ? 'human' : .account_type"
            # Employee ID mapping
            employee_ids:
              - ".employee_id"
            # Last login timestamp mapping (only if not null)
            last_login: ".last_login != null ? string(.last_login) : ''"
            # Manager information
            manager_id: ".manager_id"
            manager_email: ".manager_email"

            # Profile details for the user
            profile:
              user_id: ".id"
              created_at: ".created_at"
              last_login: ".last_login != null ? string(.last_login) : ''"
              manager_id: ".manager_id"
              manager_username: ".manager_username"
              manager_email: ".manager_email"

    # Account provisioning configuration with password support
    account_provisioning:
      schema:
        - name: "username"
          description: "The username for the new PostgreSQL user"
          type: "string"
          placeholder: "new_user"
          required: true
        - name: "email"
          description: "Email address for the new user"
          type: "string"
          placeholder: "user@example.com"
          required: true
        - name: "employee_id"
          description: "Employee ID for the new user"
          type: "string"
          placeholder: "EMP001"
          required: false
      credentials:
        random_password:
          max_length: 32
          min_length: 16
          preferred: true
        no_password:
          preferred: false
      validate:
        vars:
          username: "username"
          email: "email"
        query: |
          SELECT
            u.id, 
            u.username,
            u.email,
            u.employee_id,
            u.status,
            u.account_type,
            u.created_at,
            u.last_login,
            u.manager_id,
            m.username as manager_username,
            m.email as manager_email
          FROM users u
          LEFT JOIN users m ON u.manager_id = m.id
          WHERE u.username = ?<username>
      create:
        vars:
          username: "input.username"
          email: "input.email"
          employee_id: "has(input.employee_id) ? input.employee_id : null"
          password: "password"
        queries:
          # Insert the new user with generated password (PostgreSQL style)
          - |
            INSERT INTO users (username, email, employee_id, status, account_type, created_at, password_hash) 
            VALUES (?<username>, ?<email>, ?<employee_id>, 'active', 'human', NOW(), crypt(?<password>, gen_salt('bf')))

  # Configuration for "role" resources
  role:
    # Display name for the role resource type
    name: "Role"
    # Brief description of what a role signifies
    description: "A role within the PostgreSQL system"
    # Settings for listing roles from the database
    list:
      # SQL query to retrieve roles
      query: |
        SELECT
          id,
          role_name
        FROM
          roles
      # Pagination configuration
      pagination:
        strategy: "offset"
        primary_key: "id"
      # Mapping of each query result to role resource fields
      map:
        # Unique role identifier
        id: ".role_name"
        # Display name for the role
        display_name: ".role_name"
        # Role description
        description: "'PostgreSQL role: ' + .role_name"
        # Additional role-specific traits
        traits:
          role:
            # Profile mapping for the role
            profile:
              role_id: ".id"

    # Define a static entitlement for role membership
    static_entitlements:
      - id: "member"
        display_name: "'Member'"
        description: "'Role member'"
        purpose: "assignment"
        grantable_to:
          - "user"

    # Dynamic grants based on SQL queries to associate users with roles
    grants:
      - query: |
          SELECT 
            u.username,
            r.role_name
          FROM 
            users u
          JOIN 
            user_roles ur ON u.id = ur.user_id
          JOIN 
            roles r ON r.id = ur.role_id
        pagination:
          strategy: "offset"
          primary_key: "username"
        map:
          - skip_if: ".role_name != resource.ID"
            principal_id: ".username"
            principal_type: "user"
            entitlement_id: "member"

  feature:
    name: "Feature"
    description: "A Feature in the App"
    list:
      query: |
        SELECT
          f.id AS feat_id,
          f.name AS feat_name,
          f.description AS feat_desc
        FROM features f
        where f.is_deleted = false
      map:
        id: ".feat_id"
        display_name: ".feat_name"
        description: ".feat_desc"
        traits:
          feature:
            profile:
              - feature_id: ".feat_id"
      pagination:
        strategy: "offset"
        primary_key: "feat_id"
    static_entitlements:
      - id: "assigned"
        display_name: "'Assigned'"
        description: "'Assigned'"
        purpose: "permission"
        grantable_to:
          - "user"
          - "role"
    grants:
      - query: |
          SELECT DISTINCT
            fr.feature_id AS feat_id,
            fr.role_id AS role_id,
            f.name AS feat_name, 
            r.role_name AS role_name
          FROM feature_roles fr
          JOIN roles r
          ON r.id = fr.role_id
          JOIN features f
          ON f.id = fr.feature_id
          WHERE f.is_deleted = false
        map:
          - skip_if: "string(.feat_id) != resource.ID"
            principal_id: ".role_name"
            principal_type: "role"
            entitlement_id: "assigned"
            expandable:
              # skip_if: ".principal_type == 'role'"
              entitlement_ids:
                - "'role:' + .role_name + ':member'"
              shallow: true
